../../Sketchbook_Devel/CommandStation-EX/CommandDistributor.cpp::
../../Sketchbook_Devel/CommandStation-EX/DCC.cpp::
73,74c73
< void DCC::begin(const FSH * motorShieldName) {
<   shieldName=(FSH *)motorShieldName;
---
> void DCC::begin() {
../../Sketchbook_Devel/CommandStation-EX/DCCACK.cpp::
../../Sketchbook_Devel/CommandStation-EX/DCCEXParser.cpp::
221a222,224
> #ifdef DISABLE_PROG
>     (void)ringStream;
> #endif
470c473
<         if (params==0 || MotorDriver::commonFaultPin) { // <1> or tracks can not be handled individually
---
>         if (params==0) { // All
489a493
>         TrackManager::setJoin(join);
492d495
<         TrackManager::setJoin(join);
503c506
<         if (params==0 || MotorDriver::commonFaultPin) { // <0> or tracks can not be handled individually
---
>         if (params==0) { // All
518a522
>         TrackManager::setJoin(false);
524d527
<         TrackManager::setJoin(false);
655,656c658,663
<                 else StringFormatter::send(stream,F(" %d \"%S\" \"%S\""), 
<                     id, RMFT2::getRosterName(id), RMFT2::getRosterFunctions(id));
---
>                 else {
> 		  const FSH * functionNames= RMFT2::getRosterFunctions(id);
> 		  StringFormatter::send(stream,F(" %d \"%S\" \"%S\""), 
> 					id, RMFT2::getRosterName(id),
> 					functionNames == NULL ? RMFT2::getRosterFunctions(0) : functionNames);
> 		}
../../Sketchbook_Devel/CommandStation-EX/DCCRMT.cpp::
196a197
>   noInterrupts();                      // keep dataReady and dataRepeat consistnet to each other
198a200
>   interrupts();
214a217,218
>     if (dataRepeat == 0)       // all data should go out at least once
>       DIAG(F("Channel %d DCC signal lost data"), channel);
../../Sketchbook_Devel/CommandStation-EX/DCCTimerAVR.cpp::
3c3
<  *  © 2021-2022 Harald Barth
---
>  *  © 2021-2023 Harald Barth
31a32,34
> #ifdef DEBUG_ADC
> #include "TrackManager.h"
> #endif
130a134
> uint8_t ADCee::highestPin = 0;
132d135
< byte *ADCee::idarr = NULL;
142d144
<   byte n;
149c151
<   if (analogvals == NULL) {
---
>   if (analogvals == NULL)
151,163c153,155
<     for (n=0 ; n < NUM_ADC_INPUTS; n++) // set unreasonable value at startup as marker
<       analogvals[n] = -32768;           // 16 bit int min value
<     idarr = (byte *)calloc(NUM_ADC_INPUTS+1, sizeof(byte));  // +1 for terminator value
<     for (n=0 ; n <= NUM_ADC_INPUTS; n++)
<       idarr[n] = 255;                   // set 255 as end of array marker
<   }
<   analogvals[id] = value; // store before enable by idarr[n]
<   for (n=0 ; n <= NUM_ADC_INPUTS; n++) {
<     if (idarr[n] == 255) {
<       idarr[n] = id;
<       break;
<     }
<   }
---
>   analogvals[id] = value;
>   usedpins |= (1<<id);
>   if (id > highestPin) highestPin = id;
173d164
<   (void)fromISR; // AVR does ignore this arg
175c166,167
<   int a;
---
>   if ((usedpins & (1<<id) ) == 0)
>     return -1023;
178,180c170,172
<   noInterrupts();
<   a = analogvals[id];
<   interrupts();
---
>   if (!fromISR) noInterrupts();
>   int a = analogvals[id];
>   if (!fromISR) interrupts();
189c181,182
<   static byte num = 0;       // index into id array
---
>   static byte id = 0;       // id and mask are the same thing but it is faster to
>   static uint16_t mask = 1; // increment and shift instead to calculate mask from id
201c194,198
<     analogvals[idarr[num]] = (high << 8) | low;
---
>     analogvals[id] = (high << 8) | low;
>     // advance at least one track
> #ifdef DEBUG_ADC
>     if (id == 1) TrackManager::track[1]->setBrake(0);
> #endif
202a200,205
>     id++;
>     mask = mask << 1;
>     if (id > highestPin) {
>       id = 0;
>       mask = 1;
>     }
205,208c208,212
<     // cycle around in-use analogue pins
<     num++;
<     if (idarr[num] == 255)
<       num = 0;
---
>     if (usedpins == 0) // otherwise we would loop forever
>       return;
>     // look for a valid track to sample or until we are around
>     while (true) {
>       if (mask  & usedpins) {
212c216
<       if (idarr[num] > 7)              // if we use a high ADC pin
---
> 	  if (id > 7)          // if we use a high ADC pin
218c222
<     ADMUX = (1 << REFS0) | (idarr[num] & 0x07); // select AVCC as reference and set MUX
---
> 	ADMUX=(1<<REFS0)|(id & 0x07); //select AVCC as reference and set MUX
219a224,226
> #ifdef DEBUG_ADC
> 	if (id == 1) TrackManager::track[1]->setBrake(1);
> #endif
220a228,236
> 	return;
>       }
>       id++;
>       mask = mask << 1;
>       if (id > highestPin) {
>       	id = 0;
> 	      mask = 1;
>       }
>     }
../../Sketchbook_Devel/CommandStation-EX/DCCTimerESP.cpp::
183d182
<       ledcAttachPin(pin, cnt_channel);
184a184
>       ledcAttachPin(pin, cnt_channel);
../../Sketchbook_Devel/CommandStation-EX/DCCTimerMEGAAVR.cpp::
../../Sketchbook_Devel/CommandStation-EX/DCCTimerSAMD.cpp::
../../Sketchbook_Devel/CommandStation-EX/DCCTimerSTM32.cpp::
32a33,36
> #ifdef DEBUG_ADC
> #include "TrackManager.h"
> #endif
> #include "DIAG.h"
34,35c38,39
< #if defined(ARDUINO_NUCLEO_F411RE)
< // Nucleo-64 boards don't have Serial1 defined by default
---
> #if defined(ARDUINO_NUCLEO_F401RE) || defined(ARDUINO_NUCLEO_F411RE)
> // Nucleo-64 boards don't have additional serial ports defined by default
40c44
< HardwareSerial Serial3(PA12, PA11);  // Rx=PA12, Tx=PA11 -- CN10 pins 12 and 14 - F411RE
---
> HardwareSerial Serial6(PA12, PA11);  // Rx=PA12, Tx=PA11 -- CN10 pins 12 and 14 - F411RE
42c46,47
< // Nucleo-64 boards don't have Serial1 defined by default
---
> // Nucleo-64 boards don't have additional serial ports defined by default
> // On the F446RE, Serial1 isn't really useable as it's Rx/Tx pair sit on already used D2/D10 pins
46,49c51,55
< HardwareSerial Serial1(PC11, PC10);  // Rx=PC11, Tx=PC10 -- USART3 - F446RE
< HardwareSerial Serial3(PD2, PC12);  // Rx=PC7, Tx=PC6 -- UART5 - F446RE
< // NB: USART3 and USART6 are available but as yet undefined
< #elif defined(ARDUINO_NUCLEO_F412ZG) || defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F446ZE)
---
> // On the F446RE, Serial3 and Serial5 are easy to use:
> HardwareSerial Serial3(PC11, PC10);  // Rx=PC11, Tx=PC10 -- USART3 - F446RE
> HardwareSerial Serial5(PD2, PC12);  // Rx=PC7, Tx=PC6 -- UART5 - F446RE
> // On the F446RE, Serial4 and Serial6 also use pins we can't readily map while using the Arduino pins
> #elif defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F446ZE)|| defined(ARDUINO_NUCLEO_F412ZG) 
51,53c57,58
< HardwareSerial Serial1(PC11, PC10);  // Rx=PC11, Tx=PC10 -- USART3 - F412ZG/F446ZE
< HardwareSerial Serial3(PD2, PC12);  // Rx=PC7, Tx=PC6 -- UART5 - F412ZG/F446ZE
< // Serial2 is defined to use USART2 by default, but is in fact used as the diag console
---
> HardwareSerial Serial6(PG9, PG14);  // Rx=PG9, Tx=PG14 -- USART6
> // Serial3 is defined to use USART3 by default, but is in fact used as the diag console
55,58d59
< // NB:
< //    On all of the above, USART3, and USART6 are available but as yet undefined
< //    On F446ZE and F429ZI, UART4, UART5 are also available but as yet undefined
< //    On F429ZI, UART7 and UART8 are also available but as yet undefined
237,238d237
< #define NUM_ADC_INPUTS NUM_ANALOG_INPUTS
< 
242a242,245
> // For now, define the max of 16 ports - some variants have more, but this not **yet** supported
> #define NUM_ADC_INPUTS 16
> // #define NUM_ADC_INPUTS NUM_ANALOG_INPUTS
> 
243a247
> uint8_t ADCee::highestPin = 0;
313a318,320
>   if (id > highestPin) highestPin = id; // Store our highest pin in use
> 
>   DIAG(F("ADCee::init(): value=%d, channel=%d, id=%d"), value, adcchan, id);
348c355,357
<     // for scope debug TrackManager::track[1]->setBrake(0);
---
> #ifdef DEBUG_ADC
>     if (id == 1) TrackManager::track[1]->setBrake(0);
> #endif
352c361
<     if (id == NUM_ADC_INPUTS+1) {
---
>     if (id > highestPin) { // the 1 has been shifted out
366c375,377
< 	      // for scope debug TrackManager::track[1]->setBrake(1);
---
> #ifdef DEBUG_ADC
> 	if (id == 1) TrackManager::track[1]->setBrake(1);
> #endif
372c383
<       if (id == NUM_ADC_INPUTS+1) {
---
>       if (id > highestPin) {
../../Sketchbook_Devel/CommandStation-EX/DCCTimerTEENSY.cpp::
../../Sketchbook_Devel/CommandStation-EX/DCCWaveform.cpp::
256a257,259
> // DIAG repeated commands (accesories)
> //  if (pendingRepeats > 0)
> //    DIAG(F("Repeats=%d on %s track"), pendingRepeats, isMainTrack ? "MAIN" : "PROG");
../../Sketchbook_Devel/CommandStation-EX/Display.cpp::
../../Sketchbook_Devel/CommandStation-EX/DisplayInterface.cpp::
../../Sketchbook_Devel/CommandStation-EX/EEStore.cpp::
../../Sketchbook_Devel/CommandStation-EX/EXRAIL2.cpp::
../../Sketchbook_Devel/CommandStation-EX/EthernetInterface.cpp::
../../Sketchbook_Devel/CommandStation-EX/I2CManager.cpp::
../../Sketchbook_Devel/CommandStation-EX/IODevice.cpp::
../../Sketchbook_Devel/CommandStation-EX/IO_DCCAccessory.cpp::
../../Sketchbook_Devel/CommandStation-EX/IO_PCA9685.cpp::
../../Sketchbook_Devel/CommandStation-EX/IO_Servo.cpp::
../../Sketchbook_Devel/CommandStation-EX/LCN.cpp::
../../Sketchbook_Devel/CommandStation-EX/LiquidCrystal_I2C.cpp::
../../Sketchbook_Devel/CommandStation-EX/MotorDriver.cpp::
30c30
< bool MotorDriver::commonFaultPin=false;
---
> unsigned long MotorDriver::globalOverloadStart = 0;
38c38
<   bool pinWarning = false;
---
>   const FSH * warnString = F("** WARNING **");
100c100
<       pinWarning = true;
---
>       DIAG(F("%S Brake pin %d > %d"), warnString, brake_pin, MAX_PIN);
111,112c111,117
<   if (currentPin!=UNUSED_PIN)
<     ADCee::init(currentPin);
---
>   if (currentPin!=UNUSED_PIN) {
>     int ret = ADCee::init(currentPin);
>     if (ret < -1010) { // XXX give value a name later
>       DIAG(F("ADCee::init error %d, disable current pin %d"), ret, currentPin);
>       currentPin = UNUSED_PIN;
>     }
>   }
115c120
<   if (faultPin != UNUSED_PIN) {
---
>   if (fault_pin != UNUSED_PIN) {
120c125
<       pinWarning = true;
---
>       DIAG(F("%S Fault pin %d > %d"), warnString, fault_pin, MAX_PIN);
133c138,142
<   rawCurrentTripValue=mA2raw(trip_milliamps);
---
> #ifdef MAX_CURRENT
>   if (MAX_CURRENT > 0 && MAX_CURRENT < tripMilliamps)
>     tripMilliamps = MAX_CURRENT;
> #endif
>   rawCurrentTripValue=mA2raw(tripMilliamps);
148c157
<     DIAG(F("** WARNING ** No current or short detection"));
---
>     DIAG(F("%S No current or short detection"), warnString);
150c159
<     DIAG(F("Track %c, TripValue=%d"), trackLetter, rawCurrentTripValue);
---
>     DIAG(F("Pin %d Max %dmA (%d)"), currentPin, raw2mA(rawCurrentTripValue), rawCurrentTripValue);
157,163d165
<   // give general warning if pin values out of range were encountered
<   if (pinWarning)
<     DIAG(F("** WARNING ** Pin values > 255"));
< 
<   // prepare values for current detection
<   sampleDelay = 0;
<   lastSampleTaken = millis();
165d166
< 
174c175,180
<   bool on=mode==POWERMODE::ON;
---
>   if (powerMode == mode) return;
>   //DIAG(F("Track %c POWERMODE=%d"), trackLetter, (int)mode);
>   lastPowerChange[(int)mode] = micros();
>   if (mode == POWERMODE::OVERLOAD)
>     globalOverloadStart = lastPowerChange[(int)mode];
>   bool on=(mode==POWERMODE::ON || mode ==POWERMODE::ALERT);
214,215c220,221
<  * Return the current reading as pin reading 0 to 1023. If the fault
<  * pin is activated return a negative current to show active fault pin.
---
>  * Return the current reading as pin reading 0 to max resolution (1024 or 4096).
>  * If the fault pin is activated return a negative current to show active fault pin.
274a281
> #ifdef VARIABLE_TONES
282a290
> #endif
285a294
>   switch(brakePin) {
287c296,299
<   TCCR2B = (TCCR2B & B11111000) | B00000110; // set divisor on timer 2 to result in (approx) 122.55Hz
---
>     // Not worth doin something here as:
>     // If we are on pin 9 or 10 we are on Timer1 and we can not touch Timer1 as that is our DCC source.
>     // If we are on pin 5 or 6 we are on Timer 0 ad we can not touch Timer0 as that is millis() etc.
>     // We are most likely not on pin 3 or 11 as no known motor shield has that as brake.
290,292c302,322
<   TCCR2B = (TCCR2B & B11111000) | B00000110; // set divisor on timer 2 to result in (approx) 122.55Hz
<   TCCR4B = (TCCR4B & B11111000) | B00000100; // same for timer 4 but maxcount and thus divisor differs
<   TCCR5B = (TCCR5B & B11111000) | B00000100; // same for timer 5 which is like timer 4
---
>   case 9:
>   case 10:
>     // Timer2 (is differnet)
>     TCCR2A = (TCCR2A & B11111100) | B00000001; // set WGM1=0 and WGM0=1 phase correct PWM
>     TCCR2B = (TCCR2B & B11110000) | B00000110; // set WGM2=0 ; set divisor on timer 2 to 1/256 for 122.55Hz
>     //DIAG(F("2 A=%x B=%x"), TCCR2A, TCCR2B);
>     break;
>   case 6:
>   case 7:
>   case 8:
>     // Timer4
>     TCCR4A = (TCCR4A & B11111100) | B00000001; // set WGM0=1 and WGM1=0 for normal PWM 8-bit
>     TCCR4B = (TCCR4B & B11100000) | B00000100; // set WGM2=0 and WGM3=0 for normal PWM 8 bit and div 1/256 for 122.55Hz
>     break;
>   case 46:
>   case 45:
>   case 44:
>     // Timer5
>     TCCR5A = (TCCR5A & B11111100) | B00000001; // set WGM0=1 and WGM1=0 for normal PWM 8-bit
>     TCCR5B = (TCCR5B & B11100000) | B00000100; // set WGM2=0 and WGM3=0 for normal PWM 8 bit and div 1/256 for 122.55Hz
>     break;
293a324,326
>   default:
>     break;
>   }
300a334
> #ifdef VARIABLE_TONES
305a340
> #endif
344c379,432
< 
---
> void MotorDriver::throttleInrush(bool on) {
>   if (brakePin == UNUSED_PIN)
>     return;
>   if ( !(trackMode & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_EXT)))
>     return;
>   byte duty = on ? 208 : 0;
>   if (invertBrake)
>     duty = 255-duty;
> #if defined(ARDUINO_ARCH_ESP32)
>   if(on) {
>     DCCTimer::DCCEXanalogWrite(brakePin,duty);
>     DCCTimer::DCCEXanalogWriteFrequency(brakePin, 62500);
>   } else {
>     ledcDetachPin(brakePin);
>   }
> #else
>   if(on){
>     switch(brakePin) {
> #if defined(ARDUINO_AVR_UNO)
>       // Not worth doin something here as:
>       // If we are on pin 9 or 10 we are on Timer1 and we can not touch Timer1 as that is our DCC source.
>       // If we are on pin 5 or 6 we are on Timer 0 ad we can not touch Timer0 as that is millis() etc.
>       // We are most likely not on pin 3 or 11 as no known motor shield has that as brake.
> #endif
> #if defined(ARDUINO_AVR_MEGA) || defined(ARDUINO_AVR_MEGA2560)
>     case 9:
>     case 10:
>       // Timer2 (is different)
>       TCCR2A = (TCCR2A & B11111100) | B00000011; // set WGM0=1 and WGM1=1 for fast PWM
>       TCCR2B = (TCCR2B & B11110000) | B00000001; // set WGM2=0 and prescaler div=1 (max)
>       DIAG(F("2 A=%x B=%x"), TCCR2A, TCCR2B);
>       break;
>     case 6:
>     case 7:
>     case 8:
>       // Timer4
>       TCCR4A = (TCCR4A & B11111100) | B00000001; // set WGM0=1 and WGM1=0 for fast PWM 8-bit
>       TCCR4B = (TCCR4B & B11100000) | B00001001; // set WGM2=1 and WGM3=0 for fast PWM 8 bit and div=1 (max)
>       break;
>     case 46:
>     case 45:
>     case 44:
>       // Timer5
>       TCCR5A = (TCCR5A & B11111100) | B00000001; // set WGM0=1 and WGM1=0 for fast PWM 8-bit
>       TCCR5B = (TCCR5B & B11100000) | B00001001; // set WGM2=1 and WGM3=0 for fast PWM 8 bit and div=1 (max)
>       break;
> #endif
>     default:
>       break;
>     }
>   }
>   analogWrite(brakePin,duty);
> #endif
> }
372a461,521
> ///////////////////////////////////////////////////////////////////////////////////////////
> // checkPowerOverload(useProgLimit, trackno)
> // bool useProgLimit: Trackmanager knows if this track is in prog mode or in main mode
> // byte trackno: trackmanager knows it's number (could be skipped?)
> //
> // Short ciruit handling strategy:
> //
> // There are the following power states: ON ALERT OVERLOAD OFF
> // OFF state is only changed to/from manually. Power is on
> // during ON and ALERT. Power is off during OVERLOAD and OFF.
> // The overload mechanism changes between the other states like
> //
> // ON -1-> ALERT -2-> OVERLOAD -3-> ALERT -4-> ON
> // or
> // ON -1-> ALERT -4-> ON
> //
> // Times are in class MotorDriver (MotorDriver.h).
> //
> // 1. ON to ALERT:
> // Transition on fault pin condition or current overload
> //
> // 2. ALERT to OVERLOAD:
> // Transition happens if different timeouts have elapsed.
> // If only the fault pin is active, timeout is
> // POWER_SAMPLE_IGNORE_FAULT_LOW (100ms)
> // If only overcurrent is detected, timeout is
> // POWER_SAMPLE_IGNORE_CURRENT (100ms)
> // If fault pin and overcurrent are active, timeout is
> // POWER_SAMPLE_IGNORE_FAULT_HIGH (5ms)
> // Transition to OVERLOAD turns off power to the affected
> // output (unless fault pins are shared)
> // If the transition conditions are not fullfilled,
> // transition according to 4 is tested.
> //
> // 3. OVERLOAD to ALERT
> // Transiton happens when timeout has elapsed, timeout
> // is named power_sample_overload_wait. It is started
> // at POWER_SAMPLE_OVERLOAD_WAIT (40ms) at first entry
> // to OVERLOAD and then increased by a factor of 2
> // at further entries to the OVERLOAD condition. This
> // happens until POWER_SAMPLE_RETRY_MAX (10sec) is reached.
> // power_sample_overload_wait is reset by a poweroff or
> // a POWER_SAMPLE_ALL_GOOD (5sec) period during ON.
> // After timeout power is turned on again and state
> // goes back to ALERT.
> //
> // 4. ALERT to ON
> // Transition happens by watching the current and fault pin
> // samples during POWER_SAMPLE_ALERT_GOOD (20ms) time. If
> // values have been good during that time, transition is
> // made back to ON. Note that even if state is back to ON,
> // the power_sample_overload_wait time is first reset
> // later (see above).
> //
> // The time keeping is handled by timestamps lastPowerChange[]
> // which are set by each power change and by lastBadSample which
> // keeps track if conditions during ALERT have been good enough
> // to go back to ON. The time differences are calculated by
> // microsSinceLastPowerChange().
> //
> 
374,376d522
<   if (millis() - lastSampleTaken  < sampleDelay) return;
<   lastSampleTaken = millis();
<   int tripValue= useProgLimit?progTripValue:getRawCurrentTripValue();
378d523
<   // Trackname for diag messages later
380,381c525,528
<     case POWERMODE::OFF:
<       sampleDelay = POWER_SAMPLE_OFF_WAIT;
---
> 
>   case POWERMODE::OFF: {
>     lastPowerMode = POWERMODE::OFF;
>     power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
383,396c530,541
<     case POWERMODE::ON:
<       // Check current
<       lastCurrent=getCurrentRaw();
<       if (lastCurrent < 0) {
< 	  // We have a fault pin condition to take care of
< 	  lastCurrent = -lastCurrent;
< 	  setPower(POWERMODE::OVERLOAD); // Turn off, decide later how fast to turn on again
< 	  if (commonFaultPin) {
< 	      if (lastCurrent < tripValue) {
< 		      setPower(POWERMODE::ON); // maybe other track
< 	      }
< 	      // Write this after the fact as we want to turn on as fast as possible
< 	      // because we don't know which output actually triggered the fault pin
< 	      DIAG(F("COMMON FAULT PIN ACTIVE: POWERTOGGLE TRACK %c"), trackno + 'A');
---
>   }
> 
>   case POWERMODE::ON: {
>     lastPowerMode = POWERMODE::ON;
>     bool cF = checkFault();
>     bool cC = checkCurrent(useProgLimit);
>     if(cF || cC ) {
>       if (cC) {
> 	unsigned int mA=raw2mA(lastCurrent);
> 	DIAG(F("TRACK %c ALERT %s %dmA"), trackno + 'A',
> 	     cF ? "FAULT" : "",
> 	     mA);
398,400c543
< 	    DIAG(F("TRACK %c FAULT PIN ACTIVE - OVERLOAD"), trackno + 'A');
< 	      if (lastCurrent < tripValue) {
< 		  lastCurrent = tripValue; // exaggerate
---
> 	DIAG(F("TRACK %c ALERT FAULT"), trackno + 'A');
401a545,546
>       setPower(POWERMODE::ALERT);
>       break;
402a548,550
>     // all well
>     if (microsSinceLastPowerChange(POWERMODE::ON) > POWER_SAMPLE_ALL_GOOD) {
>       power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
404,410c552,575
<       if (lastCurrent < tripValue) {
<         sampleDelay = POWER_SAMPLE_ON_WAIT;
< 	if(power_good_counter<100)
< 	  power_good_counter++;
< 	else
< 	  if (power_sample_overload_wait>POWER_SAMPLE_OVERLOAD_WAIT) power_sample_overload_wait=POWER_SAMPLE_OVERLOAD_WAIT;
<       } else {
---
>     break;
>   }
> 
>   case POWERMODE::ALERT: {
>     // set local flags that handle how much is output to diag (do not output duplicates)
>     bool notFromOverload = (lastPowerMode != POWERMODE::OVERLOAD);
>     bool powerModeChange = (powerMode != lastPowerMode);
>     unsigned long now = micros();
>     if (powerModeChange)
>       lastBadSample = now;
>     lastPowerMode = POWERMODE::ALERT;
>     // check how long we have been in this state
>     unsigned long mslpc = microsSinceLastPowerChange(POWERMODE::ALERT);
>     if(checkFault()) {
>       throttleInrush(true);
>       lastBadSample = now;
>       unsigned long timeout = checkCurrent(useProgLimit) ? POWER_SAMPLE_IGNORE_FAULT_HIGH : POWER_SAMPLE_IGNORE_FAULT_LOW;
>       if ( mslpc < timeout) {
> 	if (powerModeChange)
> 	  DIAG(F("TRACK %c FAULT PIN (%M ignore)"), trackno + 'A', timeout);
> 	break;
>       }
>       DIAG(F("TRACK %c FAULT PIN detected after %4M. Pause %4M)"), trackno + 'A', mslpc, power_sample_overload_wait);
>       throttleInrush(false);
411a577,582
>       break;
>     }
>     if (checkCurrent(useProgLimit)) {
>       lastBadSample = now;
>       if (mslpc < POWER_SAMPLE_IGNORE_CURRENT) {
> 	if (powerModeChange) {
413,420c584,586
<         unsigned int maxmA=raw2mA(tripValue);
< 	      power_good_counter=0;
<         sampleDelay = power_sample_overload_wait;
<         DIAG(F("TRACK %c POWER OVERLOAD %dmA (limit %dmA) shutdown for %dms"), trackno + 'A', mA, maxmA, sampleDelay);
< 	if (power_sample_overload_wait >= 10000)
< 	    power_sample_overload_wait = 10000;
< 	else
< 	    power_sample_overload_wait *= 2;
---
> 	  DIAG(F("TRACK %c CURRENT (%M ignore) %dmA"), trackno + 'A', POWER_SAMPLE_IGNORE_CURRENT, mA);
> 	}
> 	break;
421a588,593
>       unsigned int mA=raw2mA(lastCurrent);
>       unsigned int maxmA=raw2mA(tripValue);
>       DIAG(F("TRACK %c POWER OVERLOAD %4dmA (max %4dmA) detected after %4M. Pause %4M"),
> 	   trackno + 'A', mA, maxmA, mslpc, power_sample_overload_wait);
>       throttleInrush(false);
>       setPower(POWERMODE::OVERLOAD);
423,424c595,603
<     case POWERMODE::OVERLOAD:
<       // Try setting it back on after the OVERLOAD_WAIT
---
>     }
>     // all well
>     unsigned long goodtime = micros() - lastBadSample;
>     if (goodtime > POWER_SAMPLE_ALERT_GOOD) {
>       if (true || notFromOverload) { // we did a RESTORE message XXX
> 	unsigned int mA=raw2mA(lastCurrent);
> 	DIAG(F("TRACK %c NORMAL (after %M/%M) %dmA"), trackno + 'A', goodtime, mslpc, mA);
>       }
>       throttleInrush(false);
426,428c605,620
<       sampleDelay = POWER_SAMPLE_ON_WAIT;
<       // Debug code....
<       DIAG(F("TRACK %c POWER RESTORE (check %dms)"), trackno + 'A', sampleDelay);
---
>     }
>     break;
>   }
> 
>   case POWERMODE::OVERLOAD: {
>     lastPowerMode = POWERMODE::OVERLOAD;
>     unsigned long mslpc = (commonFaultPin ? (micros() - globalOverloadStart) : microsSinceLastPowerChange(POWERMODE::OVERLOAD));
>     if (mslpc > power_sample_overload_wait) {
>       // adjust next wait time
>       power_sample_overload_wait *= 2;
>       if (power_sample_overload_wait > POWER_SAMPLE_RETRY_MAX)
> 	power_sample_overload_wait = POWER_SAMPLE_RETRY_MAX;
>       // power on test
>       DIAG(F("TRACK %c POWER RESTORE (after %4M)"), trackno + 'A', mslpc);
>       setPower(POWERMODE::ALERT);
>     }
429a622,623
>   }
> 
431c625
<       sampleDelay = 999; // cant get here..meaningless statement to avoid compiler warning.
---
>     break;
../../Sketchbook_Devel/CommandStation-EX/Outputs.cpp::
../../Sketchbook_Devel/CommandStation-EX/RingStream.cpp::
../../Sketchbook_Devel/CommandStation-EX/SSD1306Ascii.cpp::
../../Sketchbook_Devel/CommandStation-EX/Sensors.cpp::
../../Sketchbook_Devel/CommandStation-EX/SerialManager.cpp::
../../Sketchbook_Devel/CommandStation-EX/StringBuffer.cpp::
../../Sketchbook_Devel/CommandStation-EX/StringFormatter.cpp::
119a120,137
>       case 'M':
>       { // this prints a unsigned long microseconds time in readable format
> 	unsigned long time = va_arg(args, long);
> 	if (time >= 2000) {
> 	  time = time / 1000;
> 	  if (time >= 2000) {
> 	    printPadded(stream, time/1000, formatWidth, formatLeft);
> 	    stream->print(F("sec"));
> 	  } else {
> 	    printPadded(stream,time, formatWidth, formatLeft);
> 	    stream->print(F("msec"));
> 	  }
> 	} else {
> 	  printPadded(stream,time, formatWidth, formatLeft);
> 	  stream->print(F("usec"));
> 	}
>       }
>       break;
../../Sketchbook_Devel/CommandStation-EX/TrackManager.cpp::
34c34
<             if (trackMode[t]==findmode) \
---
> 	    if (track[t]->getMode()==findmode)	\
40a41
> const int16_t HASH_KEYWORD_NONE = -26550;
47d47
< TRACK_MODE TrackManager::trackMode[MAX_TRACKS];
77c77
<     if (lastTrack < 2 || trackMode[tr] & TRACK_MODE_PROG) {
---
>     if (lastTrack < 2 || track[tr]->getMode() & TRACK_MODE_PROG) {
88c88
<       if (trackMode[tr] & ( TRACK_MODE_MAIN|TRACK_MODE_PROG|TRACK_MODE_DC|TRACK_MODE_DCX|TRACK_MODE_EXT )) {
---
>       if (track[tr]->getMode() & ( TRACK_MODE_MAIN|TRACK_MODE_PROG|TRACK_MODE_DC|TRACK_MODE_DCX|TRACK_MODE_EXT )) {
126,129c126,137
<   // TODO Fault pin config for odd motor boards (example pololu)
<   // MotorDriver::commonFaultPin = ((mainDriver->getFaultPin() == progDriver->getFaultPin())
<   //				 && (mainDriver->getFaultPin() != UNUSED_PIN));
<   DCC::begin(shieldname);   
---
>   // Fault pin config for odd motor boards (example pololu)
>   FOR_EACH_TRACK(t) {
>     for (byte s=t+1;s<=lastTrack;s++) {
>       if (track[t]->getFaultPin() != UNUSED_PIN &&
> 	  track[t]->getFaultPin() == track[s]->getFaultPin()) {
> 	track[t]->setCommonFaultPin();
> 	track[s]->setCommonFaultPin();
> 	DIAG(F("Common Fault pin tracks %c and %c"), t+'A', s+'A');
>       }
>     }
>   }
>   DCC::setShieldName(shieldname);
133d140
<      trackMode[t]=TRACK_MODE_OFF;
136a144
>          track[t]->setMode(TRACK_MODE_NONE);
177,179c185,187
<     if (trackDCAddr[t]!=cab) continue;
<     if (trackMode[t]==TRACK_MODE_DC) track[t]->setDCSignal(speedbyte);
<     else if (trackMode[t]==TRACK_MODE_DCX) track[t]->setDCSignal(speedbyte ^ 128);
---
>     if (trackDCAddr[t]!=cab && cab != 0) continue;
>     if (track[t]->getMode()==TRACK_MODE_DC) track[t]->setDCSignal(speedbyte);
>     else if (track[t]->getMode()==TRACK_MODE_DCX) track[t]->setDCSignal(speedbyte ^ 128);
186c194
<     //DIAG(F("Track=%c"),trackToSet+'A');
---
>     //DIAG(F("Track=%c Mode=%d"),trackToSet+'A', mode);
188,189c196,201
<     if ((mode==TRACK_MODE_DC || mode==TRACK_MODE_DCX)
<          && !track[trackToSet]->brakeCanPWM()) {
---
>     if (mode==TRACK_MODE_DC || mode==TRACK_MODE_DCX) {
> #if defined(ARDUINO_AVR_UNO)
>       DIAG(F("Uno has no PWM timers available for DC"));
>       return false;
> #endif
>       if (!track[trackToSet]->brakeCanPWM()) {
192a205
>     }
213c226
< 	if (trackMode[t]==TRACK_MODE_PROG && t != trackToSet) {
---
> 	if (track[t]->getMode()==TRACK_MODE_PROG && t != trackToSet) {
215c228
< 	  trackMode[t]=TRACK_MODE_OFF;
---
> 	  track[t]->setMode(TRACK_MODE_NONE);
223c236
<     trackMode[trackToSet]=mode;
---
>     track[trackToSet]->setMode(mode);
250c263
<       if (trackMode[t]==TRACK_MODE_DC || trackMode[t]==TRACK_MODE_DCX) {
---
>       if (track[t]->getMode()==TRACK_MODE_DC || track[t]->getMode()==TRACK_MODE_DCX) {
258c271
<       } else if (trackMode[t]==TRACK_MODE_MAIN || trackMode[t]==TRACK_MODE_PROG) {
---
>       } else if (track[t]->getMode()==TRACK_MODE_MAIN || track[t]->getMode()==TRACK_MODE_PROG) {
296c309
<   if (trackMode[t]==TRACK_MODE_DCX)
---
>   if (track[t]->getMode()==TRACK_MODE_DCX)
323,324c336,337
<     if (params==2  && p[1]==HASH_KEYWORD_OFF) // <= id OFF>
<         return setTrackMode(p[0],TRACK_MODE_OFF);
---
>     if (params==2  && (p[1]==HASH_KEYWORD_OFF || p[1]==HASH_KEYWORD_NONE)) // <= id OFF> <= id NONE>
>         return setTrackMode(p[0],TRACK_MODE_NONE);
342c355
<   switch(trackMode[t]) {
---
>   switch(track[t]->getMode()) {
351,352c364,365
<   case TRACK_MODE_OFF:
<       format=F("<= %c OFF>\n");
---
>   case TRACK_MODE_NONE:
>       format=F("<= %c NONE>\n");
382c395
<     bool useProgLimit=dontLimitProg? false: trackMode[nextCycleTrack]==TRACK_MODE_PROG;
---
>     bool useProgLimit=dontLimitProg? false: track[nextCycleTrack]->getMode()==TRACK_MODE_PROG;
388c401
<         if (trackMode[t]==TRACK_MODE_PROG) return track[t];
---
>       if (track[t]->getMode()==TRACK_MODE_PROG) return track[t];
396c409
<     if (trackMode[t]==TRACK_MODE_MAIN) v.push_back(track[t]);
---
>     if (track[t]->getMode()==TRACK_MODE_MAIN) v.push_back(track[t]);
406c419
<         switch (trackMode[t]) {
---
>         switch (track[t]->getMode()) {
434c447
<             case TRACK_MODE_OFF:
---
>             case TRACK_MODE_NONE:
442c455
<         if (trackMode[t]==TRACK_MODE_PROG) 
---
>       if (track[t]->getMode()==TRACK_MODE_PROG) 
487c500
<       if (trackMode[t]==TRACK_MODE_PROG) {
---
>       if (track[t]->getMode()==TRACK_MODE_PROG) {
../../Sketchbook_Devel/CommandStation-EX/Turnouts.cpp::
../../Sketchbook_Devel/CommandStation-EX/WiThrottle.cpp::
535a536,537
>       if (cabid == INT16_MAX)
> 	break;
539,540d540
<       else if (cabid == INT16_MAX)
< 	break;
577,578c577,578
< 	const char * functionNames=(char *) RMFT2::getRosterFunctions(locoid);
< 	if (!functionNames) {
---
> 	const FSH * functionNames= RMFT2::getRosterFunctions(locoid);
> 	if (functionNames == NULL) {
580c580
< 	  functionNames=(char *) RMFT2::getRosterFunctions(0);
---
> 	  functionNames= RMFT2::getRosterFunctions(0);
582c582
< 	if (!functionNames) {
---
> 	if (functionNames == NULL) {
598c598
< 	    char c=GETFLASH(functionNames+fx);
---
> 	    char c=GETFLASH((char *)functionNames+fx);
../../Sketchbook_Devel/CommandStation-EX/WifiESP32.cpp::
2c2,4
<     © 2021, Harald Barth.
---
>     © 2023 Paul M. Antoine
>     © 2021 Harald Barth
>     © 2023 Nathan Kellenicki
25a28
> #include "ESPmDNS.h"
110a114,119
> char asciitolower(char in) {
>   if (in <= 'Z' && in >= 'A')
>     return in - ('Z' - 'z');
>   return in;
> }
> 
115c124,125
<                     const byte channel) {
---
>                     const byte channel,
>                     const bool forceAP) {
143c153,154
<   if (haveSSID && havePassword) {
---
>   if (haveSSID && havePassword && !forceAP) {
>     WiFi.setHostname(hostname); // Strangely does not work unless we do it HERE!
180c191
<   if (!haveSSID) {
---
>   if (!haveSSID || forceAP) {
182,183c193,195
<     String strSSID("DCC_");
<     String strPass("PASS_");
---
>     String strSSID(forceAP ? SSid : "DCCEX_");
>     String strPass(forceAP ? password : "PASS_");
>     if (!forceAP) {
187a200,201
>       // convert mac addr hex chars to lower case to be compatible with AT software
>       std::transform(strMac.begin(), strMac.end(), strMac.begin(), asciitolower);
189a204
>     }
222a238,246
> 
>   // Now Wifi is up, register the mDNS service
>   if(!MDNS.begin(hostname)) {
>     DIAG(F("Wifi setup failed to start mDNS"));
>   }
>   if(!MDNS.addService("withrottle", "tcp", 2560)) {
>     DIAG(F("Wifi setup failed to add withrottle service to mDNS"));
>   }
> 
../../Sketchbook_Devel/CommandStation-EX/WifiInboundHandler.cpp::
../../Sketchbook_Devel/CommandStation-EX/WifiInterface.cpp::
4a5
>  *  © 2023 Nathan Kellenicki
57a59,79
> #define SERIAL1 Serial1
> #define SERIAL3 Serial3
> #endif
> 
> #if defined(ARDUINO_ARCH_STM32)
> // Handle serial ports availability on STM32 for variants!
> // #undef NUM_SERIAL
> #if defined(ARDUINO_NUCLEO_F401RE) || defined(ARDUINO_NUCLEO_F411RE)
> #define NUM_SERIAL 3
> #define SERIAL1 Serial1
> #define SERIAL3 Serial6
> #elif defined(ARDUINO_NUCLEO_F446RE)
> #define NUM_SERIAL 3
> #define SERIAL1 Serial3
> #define SERIAL3 Serial5
> #elif defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F446ZE) || defined(ARDUINO_NUCLEO_F412ZG)
> #define NUM_SERIAL 2
> #define SERIAL1 Serial6
> #else
> #warning This variant of Nucleo not yet explicitly supported
> #endif
61a84
> #define SERIAL1 Serial1
64,71d86
< // For STM32 we need to define Serial3 in the platform specific
< // DCCTimerSTM32.cpp file, we here make the assumption that it
< // exists to link against.
< #ifdef ARDUINO_ARCH_STM32
< #if NUM_SERIAL > 2
< extern HardwareSerial Serial3;
< #endif
< #endif
77c92,93
<                           const byte channel) {
---
>                           const byte channel,
>                           const bool forceAP) {
88a105
>   (void) forceAP;
90a108
> // See if the WiFi is attached to the first serial port
92,93c110,111
<   Serial1.begin(serial_link_speed);
<   wifiUp = setup(Serial1, wifiESSID, wifiPassword, hostname, port, channel);
---
>   SERIAL1.begin(serial_link_speed);
>   wifiUp = setup(SERIAL1, wifiESSID, wifiPassword, hostname, port, channel, forceAP);
97c115
< // Currently only the Arduino Mega 2560 has usable Serial2
---
> // Currently only the Arduino Mega 2560 has usable Serial2 (Nucleo-64 boards use Serial 2 for console!)
103c121
<     wifiUp = setup(Serial2, wifiESSID, wifiPassword, hostname, port, channel);
---
>     wifiUp = setup(Serial2, wifiESSID, wifiPassword, hostname, port, channel, forceAP);
113,114c131,132
<     Serial3.begin(serial_link_speed);
<     wifiUp = setup(Serial3, wifiESSID, wifiPassword, hostname, port, channel);
---
>     SERIAL3.begin(serial_link_speed);
>     wifiUp = setup(SERIAL3, wifiESSID, wifiPassword, hostname, port, channel, forceAP);
132c150
< 				     const FSH* hostname,  int port, byte channel) {
---
> 				     const FSH* hostname,  int port, byte channel, bool forceAP) {
141c159
<   wifiState = setup2( SSid, password, hostname,  port, channel);
---
>   wifiState = setup2( SSid, password, hostname,  port, channel, forceAP);
165c183
< 				      const FSH* hostname, int port, byte channel) {
---
> 				      const FSH* hostname, int port, byte channel, bool forceAP) {
218c236
<   } else {
---
>   } else if (!forceAP) {
277a296
>       if (!forceAP) {
286a306,309
>       } else {
>         StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"%S\",\"%S\",%d,4\r\n"),
>                                         oldCmd ? "" : "_CUR", SSid, password, channel);
>       }
../../Sketchbook_Devel/CommandStation-EX/CommandDistributor.h::
../../Sketchbook_Devel/CommandStation-EX/DCC.h::
54c54,57
<   static void begin(const FSH * motorShieldName);
---
>   static inline void setShieldName(const FSH * motorShieldName) {
>     shieldName=(FSH *)motorShieldName;
>   };
>   static void begin();
../../Sketchbook_Devel/CommandStation-EX/DCCACK.h::
../../Sketchbook_Devel/CommandStation-EX/DCCEX.h::
../../Sketchbook_Devel/CommandStation-EX/DCCEXParser.h::
../../Sketchbook_Devel/CommandStation-EX/DCCRMT.h::
../../Sketchbook_Devel/CommandStation-EX/DCCTimer.h::
108c108,112
<   // init does add the pin to the list of scanned pins (if this
---
>   // begin is called for any setup that must be done before
>   // **init** can be called. On some architectures this involves ADC
>   // initialisation and clock routing, sampling times etc.
>   static void begin();
>   // init adds the pin to the list of scanned pins (if this
110c114,115
<   // read value. It is called before the regular scan is started.
---
>   // read value (which is why it required begin to have been called first!)
>   // It must be called before the regular scan is started.
119,121d123
<   // begin is called for any setup that must be done before
<   // scan can be called.
<   static void begin();
127a130
>   static uint8_t highestPin;
130,131d132
<   // ids to scan (new way)
<   static byte *idarr;
../../Sketchbook_Devel/CommandStation-EX/DCCWaveform.h::
../../Sketchbook_Devel/CommandStation-EX/DIAG.h::
../../Sketchbook_Devel/CommandStation-EX/DRLdefines.h::
../../Sketchbook_Devel/CommandStation-EX/Display.h::
../../Sketchbook_Devel/CommandStation-EX/DisplayInterface.h::
../../Sketchbook_Devel/CommandStation-EX/Display_Implementation.h::
../../Sketchbook_Devel/CommandStation-EX/EEStore.h::
../../Sketchbook_Devel/CommandStation-EX/EXRAIL.h::
../../Sketchbook_Devel/CommandStation-EX/EXRAIL2.h::
../../Sketchbook_Devel/CommandStation-EX/EXRAIL2MacroReset.h::
../../Sketchbook_Devel/CommandStation-EX/EXRAILMacros.h::
226c226
<    return F("");
---
>    return NULL;
../../Sketchbook_Devel/CommandStation-EX/EthernetInterface.h::
../../Sketchbook_Devel/CommandStation-EX/FSH.h::
../../Sketchbook_Devel/CommandStation-EX/GITHUB_SHA.h::
1c1
< #define GITHUB_SHA "devel-202305242057Z"
---
> #define GITHUB_SHA "3bddf4d"
../../Sketchbook_Devel/CommandStation-EX/I2CManager.h::
../../Sketchbook_Devel/CommandStation-EX/I2CManager_AVR.h::
../../Sketchbook_Devel/CommandStation-EX/I2CManager_Mega4809.h::
../../Sketchbook_Devel/CommandStation-EX/I2CManager_NonBlocking.h::
../../Sketchbook_Devel/CommandStation-EX/I2CManager_SAMD.h::
../../Sketchbook_Devel/CommandStation-EX/I2CManager_STM32.h::
../../Sketchbook_Devel/CommandStation-EX/I2CManager_Wire.h::
../../Sketchbook_Devel/CommandStation-EX/IODevice.h::
../../Sketchbook_Devel/CommandStation-EX/IO_AnalogueInputs.h::
../../Sketchbook_Devel/CommandStation-EX/IO_DFPlayer.h::
../../Sketchbook_Devel/CommandStation-EX/IO_EXFastclock.h::
../../Sketchbook_Devel/CommandStation-EX/IO_EXIOExpander.h::
../../Sketchbook_Devel/CommandStation-EX/IO_EXTurntable.h::
53d52
<   I2CManager.setClock(1000000);
58a58
>     DIAG(F("EX-Turntable I2C:%s device not found"), _I2CAddress.toString());
../../Sketchbook_Devel/CommandStation-EX/IO_ExampleSerial.h::
../../Sketchbook_Devel/CommandStation-EX/IO_GPIOBase.h::
../../Sketchbook_Devel/CommandStation-EX/IO_HALDisplay.h::
../../Sketchbook_Devel/CommandStation-EX/IO_HCSR04.h::
../../Sketchbook_Devel/CommandStation-EX/IO_MCP23008.h::
../../Sketchbook_Devel/CommandStation-EX/IO_MCP23017.h::
../../Sketchbook_Devel/CommandStation-EX/IO_PCA9685pwm.h::
../../Sketchbook_Devel/CommandStation-EX/IO_PCF8574.h::
../../Sketchbook_Devel/CommandStation-EX/IO_PCF8575.h::
../../Sketchbook_Devel/CommandStation-EX/IO_RotaryEncoder.h::
1a2
>  *  © 2023, Peter Cole. All rights reserved.
31c32
< * Further to this, feedback can be sent to the rotary encoder by using 2 Vpins, and sending a SET()/RESET() to the second Vpin.
---
> * Feedback can also be sent to the rotary encoder by using 2 Vpins, and sending a SET()/RESET() to the second Vpin.
33a35,48
> * In addition, defining a third Vpin will allow a position number to be sent so that when an EXRAIL automation or some other
> * activity has moved a turntable, the position can be reflected in the rotary encoder software. This can be accomplished
> * using the EXRAIL SERVO(vpin, position, profile) command, where:
> * - vpin = the third defined Vpin (any other is ignored)
> * - position = the defined position in the DCC-EX Rotary Encoder software, 0 (Home) to 255
> * - profile = Must be defined as per the SERVO() command, but is ignored as it has no relevance
> *
> * Defining in myAutomation.h requires the device driver to be included in addition to the HAL() statement. Examples:
> *
> * #include "IO_RotaryEncoder.h"
> * HAL(RotaryEncoder, 700, 1, 0x70)    // Define single Vpin, no feedback or position sent to rotary encoder software
> * HAL(RotaryEncoder, 700, 2, 0x70)    // Define two Vpins, feedback only sent to rotary encoder software
> * HAL(RotaryEncoder, 700, 3, 0x70)    // Define three Vpins, can send feedback and position update to rotary encoder software
> *
46a62,67
>   
>   static void create(VPIN firstVpin, int nPins, I2CAddress i2cAddress) {
>     if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new RotaryEncoder(firstVpin, nPins, i2cAddress);
>   }
> 
> private:
50a72,75
>     if (_nPins > 3) {
>       _nPins = 3;
>       DIAG(F("RotaryEncoder WARNING:%d vpins defined, only 3 supported"), _nPins);
>     }
54,56d78
<   static void create(VPIN firstVpin, int nPins, I2CAddress i2cAddress) {
<     if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new RotaryEncoder(firstVpin, nPins, i2cAddress);
<   }
58d79
< private:
60a82,83
>     uint8_t _status;
>     // Attempt to initilalise device
63,64c86,92
<       byte _getVersion[1] = {RE_VER};
<       I2CManager.read(_I2CAddress, _versionBuffer, 3, _getVersion, 1);
---
>       // Send RE_RDY, must receive RE_RDY to be online
>       _sendBuffer[0] = RE_RDY;
>       _status = I2CManager.read(_I2CAddress, _rcvBuffer, 1, _sendBuffer, 1);
>       if (_status == I2C_STATUS_OK) {
>         if (_rcvBuffer[0] == RE_RDY) {
>           _sendBuffer[0] = RE_VER;
>           if (I2CManager.read(_I2CAddress, _versionBuffer, 3, _sendBuffer, 1) == I2C_STATUS_OK) {
68,69c96,106
<       _buffer[0] = RE_OP;
<       I2CManager.write(_I2CAddress, _buffer, 1);
---
>           }
>         } else {
>           DIAG(F("RotaryEncoder I2C:%s garbage received: %d"), _I2CAddress.toString(), _rcvBuffer[0]);
>           _deviceState = DEVSTATE_FAILED;
>           return;
>         }
>       } else {
>         DIAG(F("RotaryEncoder I2C:%s ERROR connecting"), _I2CAddress.toString());
>         _deviceState = DEVSTATE_FAILED;
>         return;
>       }
73a111
>       DIAG(F("RotaryEncoder I2C:%s device not found"), _I2CAddress.toString());
79,81c117,125
<     I2CManager.read(_I2CAddress, _buffer, 1);
<     _position = _buffer[0];
<     // This here needs to have a change check, ie. position is a different value.
---
>     if (_deviceState == DEVSTATE_FAILED) return;  // Return if device has failed
>     if (_i2crb.isBusy()) return;                  // Return if I2C operation still in progress
> 
>     if (currentMicros - _lastPositionRead > _positionRefresh) {
>       _lastPositionRead = currentMicros;
>       _sendBuffer[0] = RE_READ;
>       I2CManager.read(_I2CAddress, _rcvBuffer, 1, _sendBuffer, 1, &_i2crb); // Read position from encoder
>       _position = _rcvBuffer[0];
>       // If EXRAIL is active, we need to trigger the ONCHANGE() event handler if it's in use
90c134
<     delayUntil(currentMicros + 100000);
---
>     }
93c137
<   // Device specific read function
---
>   // Return the position sent by the rotary encoder software
98a143
>   // Send the feedback value to the rotary encoder software
106a152,164
>   // Send a position update to the rotary encoder software
>   // To be valid, must be 0 to 255, and different to the current position
>   // If the current position is the same, it was initiated by the rotary encoder
>   void _writeAnalogue(VPIN vpin, int position, uint8_t profile, uint16_t duration) override {
>     if (vpin == _firstVpin + 2) {
>       if (position >= 0 && position <= 255 && position != _position) {
>         byte newPosition = position & 0xFF;
>         byte _positionBuffer[2] = {RE_MOVE, newPosition};
>         I2CManager.write(_I2CAddress, _positionBuffer, 2);
>       }
>     }
>   }
>   
115c173,174
<   uint8_t _buffer[1];
---
>   uint8_t _sendBuffer[1];
>   uint8_t _rcvBuffer[1];
118a178,180
>   I2CRB _i2crb;
>   unsigned long _lastPositionRead = 0;
>   const unsigned long _positionRefresh = 100000UL;    // Delay refreshing position for 100ms
121,122c183,187
<     RE_VER = 0xA0,   // Flag to retrieve rotary encoder version from the device
<     RE_OP = 0xA1,    // Flag for normal operation
---
>     RE_RDY = 0xA0,   // Flag to check if encoder is ready for operation
>     RE_VER = 0xA1,   // Flag to retrieve rotary encoder software version
>     RE_READ = 0xA2,  // Flag to read the current position of the encoder
>     RE_OP = 0xA3,    // Flag for operation start/end, sent to when sending feedback on move start/end
>     RE_MOVE = 0xA4,  // Flag for sending a position update from the device driver to the encoder
../../Sketchbook_Devel/CommandStation-EX/IO_Servo.h::
../../Sketchbook_Devel/CommandStation-EX/IO_TouchKeypad.h::
../../Sketchbook_Devel/CommandStation-EX/IO_VL53L0X.h::
../../Sketchbook_Devel/CommandStation-EX/IO_duinoNodes.h::
../../Sketchbook_Devel/CommandStation-EX/LCN.h::
../../Sketchbook_Devel/CommandStation-EX/LiquidCrystal_I2C.h::
../../Sketchbook_Devel/CommandStation-EX/MotorDriver.h::
29a30,33
> // use powers of two so we can do logical and/or on the track modes in if clauses.
> enum TRACK_MODE : byte {TRACK_MODE_NONE = 1, TRACK_MODE_MAIN = 2, TRACK_MODE_PROG = 4,
>                         TRACK_MODE_DC = 8, TRACK_MODE_DCX = 16, TRACK_MODE_EXT = 32};
> 
110c114
< enum class POWERMODE : byte { OFF, ON, OVERLOAD };
---
> enum class POWERMODE : byte { OFF, ON, OVERLOAD, ALERT };
147a152
>     void throttleInrush(bool on);
178c183,186
<     static bool commonFaultPin; // This is a stupid motor shield which has only a common fault pin for both outputs
---
>     bool commonFaultPin = false; // This is a stupid motor shield which has only a common fault pin for both outputs
>     inline byte setCommonFaultPin() {
>       return commonFaultPin = true;
>     }
188a197,206
>     // this returns how much time has passed since the last power change. If it
>     // was really long ago (approx > 52min) advance counter approx 35 min so that
>     // we are at 18 minutes again. Times for 32 bit unsigned long.
>     inline unsigned long microsSinceLastPowerChange(POWERMODE mode) {
>       unsigned long now = micros();
>       unsigned long diff = now - lastPowerChange[(int)mode];
>       if (diff > (1UL << (7 *sizeof(unsigned long)))) // 2^(4*7)us = 268.4 seconds
>         lastPowerChange[(int)mode] = now - 30000000UL;           // 30 seconds ago
>       return diff;
>     };
192a211,216
>   inline void setMode(TRACK_MODE m) {
>     trackMode = m;
>   };
>   inline TRACK_MODE getMode() {
>     return trackMode;
>   };
197c221
<     void  getFastPin(const FSH* type,int pin, FASTPIN & result) {
---
>     inline void  getFastPin(const FSH* type,int pin, FASTPIN & result) {
199c223,236
<     }
---
>     };
>     // side effect sets lastCurrent and tripValue
>     inline bool checkCurrent(bool useProgLimit) {
>       tripValue= useProgLimit?progTripValue:getRawCurrentTripValue();
>       lastCurrent = getCurrentRaw();
>       if (lastCurrent < 0)
> 	lastCurrent = -lastCurrent;
>       return lastCurrent >= tripValue;
>     };
>     // side effect sets lastCurrent
>     inline bool checkFault() {
>       lastCurrent = getCurrentRaw();
>       return lastCurrent < 0;
>     };
220,221c257,261
<     unsigned long lastSampleTaken;
<     unsigned int sampleDelay;
---
>     POWERMODE lastPowerMode;
>     unsigned long lastPowerChange[4];         // timestamp in microseconds
>     unsigned long lastBadSample;              // timestamp in microseconds
>     // used to sync restore time when common Fault pin detected
>     static unsigned long globalOverloadStart; // timestamp in microseconds
223c263,264
<     int  lastCurrent;
---
>     int  lastCurrent; //temp value
>     int  tripValue;   //temp value
231,234c272,286
<     // Wait times for power management. Unit: milliseconds
<     static const int  POWER_SAMPLE_ON_WAIT = 100;
<     static const int  POWER_SAMPLE_OFF_WAIT = 1000;
<     static const int  POWER_SAMPLE_OVERLOAD_WAIT = 20;
---
>     // Times for overload management. Unit: microseconds.
>     // Base for wait time until power is turned on again
>     static const unsigned long POWER_SAMPLE_OVERLOAD_WAIT =     40000UL;
>     // Time after we consider all faults old and forgotten
>     static const unsigned long POWER_SAMPLE_ALL_GOOD =        5000000UL;
>     // Time after which we consider a ALERT over 
>     static const unsigned long POWER_SAMPLE_ALERT_GOOD =        20000UL;
>     // How long to ignore fault pin if current is under limit
>     static const unsigned long POWER_SAMPLE_IGNORE_FAULT_LOW = 100000UL;
>     // How long to ignore fault pin if current is higher than limit
>     static const unsigned long POWER_SAMPLE_IGNORE_FAULT_HIGH =  5000UL;
>     // How long to wait between overcurrent and turning off
>     static const unsigned long POWER_SAMPLE_IGNORE_CURRENT  =  100000UL;
>     // Upper limit for retry period
>     static const unsigned long POWER_SAMPLE_RETRY_MAX =      10000000UL;
240a293
>     TRACK_MODE trackMode = TRACK_MODE_NONE; // we assume track not assigned at startup
../../Sketchbook_Devel/CommandStation-EX/MotorDrivers.h::
../../Sketchbook_Devel/CommandStation-EX/Outputs.h::
../../Sketchbook_Devel/CommandStation-EX/RingStream.h::
../../Sketchbook_Devel/CommandStation-EX/SSD1306Ascii.h::
../../Sketchbook_Devel/CommandStation-EX/Sensors.h::
../../Sketchbook_Devel/CommandStation-EX/SerialManager.h::
../../Sketchbook_Devel/CommandStation-EX/StringBuffer.h::
../../Sketchbook_Devel/CommandStation-EX/StringFormatter.h::
../../Sketchbook_Devel/CommandStation-EX/TrackManager.h::
30,33d29
< // use powers of two so we can do logical and/or on the track modes in if clauses.
< enum TRACK_MODE : byte {TRACK_MODE_OFF = 1, TRACK_MODE_MAIN = 2, TRACK_MODE_PROG = 4,
<                         TRACK_MODE_DC = 8, TRACK_MODE_DCX = 16, TRACK_MODE_EXT = 32};
< 
88a85,91
> #ifdef DEBUG_ADC
>   public:
> #else
>   private:
> #endif
>     static MotorDriver* track[MAX_TRACKS];
> 
96,97d98
<     static MotorDriver* track[MAX_TRACKS];
<     static TRACK_MODE trackMode[MAX_TRACKS]; 
../../Sketchbook_Devel/CommandStation-EX/Turnouts.h::
../../Sketchbook_Devel/CommandStation-EX/WiThrottle.h::
../../Sketchbook_Devel/CommandStation-EX/WifiESP32.h::
2c2,3
<  *  © 2021, Harald Barth.
---
>  *  © 2021 Harald Barth
>  *  © 2023 Nathan Kellenicki
34c35,36
< 		    const byte channel);
---
> 		    const byte channel,
> 			const bool forceAP);
../../Sketchbook_Devel/CommandStation-EX/WifiInboundHandler.h::
../../Sketchbook_Devel/CommandStation-EX/WifiInterface.h::
3a4
>  *  © 2023 Nathan Kellenicki
39c40,41
<                           const byte channel);
---
>                           const byte channel,
>                           const bool forceAP);
45c47
<                     const FSH *hostname, int port, byte channel);
---
>                     const FSH *hostname, int port, byte channel, bool forceAP);
49c51
<                      const FSH *hostname, int port, byte channel);
---
>                      const FSH *hostname, int port, byte channel, bool forceAP);
../../Sketchbook_Devel/CommandStation-EX/config.example.h::
4c4
<  *  © 2020-2021 Harald Barth
---
>  *  © 2020-2023 Harald Barth
6a7
>  *  © 2023 Nathan Kellenicki
30a32,41
> // If you want to add your own motor driver definition(s), add them here
> //   For example MY_SHIELD with display name "MINE":
> //   (remove comment start and end marker if you want to edit and use that)
> /* 
> #define MY_SHIELD F("MINE"), \
>  new MotorDriver( 3, 12, UNUSED_PIN, 9, A0, 5.08, 3000, A4), \
>  new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 5.08, 1500, A5)
> */
> 
> /////////////////////////////////////////////////////////////////////////////////////
37c48
< // DEFINE MOTOR_SHIELD_TYPE BELOW ACCORDING TO THE FOLLOWING TABLE:
---
> // DEFINE MOTOR_SHIELD_TYPE BELOW. THESE ARE EXAMPLES. FULL LIST IN MotorDrivers.h
41d51
< //  POLOLU_TB9051FTG      : Pololu Dual TB9051FTG Motor Driver
45a56
> //  EX8874_SHIELD         : DCC-EX TI DRV8874 based motor shield
49a61,75
> //
> /////////////////////////////////////////////////////////////////////////////////////
> //
> // If you want to restrict the maximum current LOWER than what your
> // motor shield can provide, you can do that here. For example if you
> // have a motor shield that can provide 5A and your power supply can
> // only provide 2.5A then you should restict the maximum current to
> // 2.25A (90% of 2.5A) so that DCC-EX does shut off the track before
> // your PS does shut DCC-EX. MAX_CURRENT is in mA so for this example
> // it would be 2250, adjust the number according to your PS. If your
> // PS has a higher rating than your motor shield you do not need this.
> // You can use this as well if you are cautious and your trains do not
> // need full current.
> // #define MAX_CURRENT 2250
> //
100a127,131
> //
> // WIFI_FORCE_AP: If you'd like to specify your own WIFI_SSID in AP mode, set this
> // true. Otherwise it is assumed that you'd like to connect to an existing network
> // with that SSID.
> #define WIFI_FORCE_AP false
../../Sketchbook_Devel/CommandStation-EX/config.h::
../../Sketchbook_Devel/CommandStation-EX/defines.h::
150,151d149
<   #undef NUM_SERIAL
<   #define NUM_SERIAL 3
186a185,193
> #ifndef WIFI_FORCE_AP
>   #define WIFI_FORCE_AP false
> #else
>   #if WIFI_FORCE_AP==true || WIFI_FORCE_AP==false
>   #else
>     #error WIFI_FORCE_AP needs to be true or false
>   #endif
> #endif
> 
210c217
<   #if defined(HAS_ENOUGH_MEMORY) || defined(DISABLE_EEPROM)
---
>   #if defined(HAS_ENOUGH_MEMORY) || defined(DISABLE_EEPROM) || defined(DISABLE_PROG)
../../Sketchbook_Devel/CommandStation-EX/myAutomation.example.h::
../../Sketchbook_Devel/CommandStation-EX/myEX-Turntable.example.h::
../../Sketchbook_Devel/CommandStation-EX/mySetup.h::
../../Sketchbook_Devel/CommandStation-EX/version.h::
6,8c6,35
< 
< #define VERSION "4.2.54pre1"
< // 4.2.54 - Fix: Pin handling supports pins up to 254
---
> #define VERSION "5.0.0"
> // 5.0.0  - Make 4.2.69 the 5.0.0 release
> // 4.2.69 - Bugfix: Make <!> work in DC mode
> // 4.2.68 - Rename track mode OFF to NONE
> // 4.2.67 - AVR: Pin specific timer register seting
> //        - Protect Uno user from choosing DC(X)
> //        - More Nucleo variant defines
> //        - GPIO PCA9555 / TCA9555 support
> // 4.2.66 - Throttle inrush current by applying PWM to brake pin when
> //          fault pin goes active
> // 4.2.65 - new config WIFI_FORCE_AP option
> // 4.2.63 - completely new overcurrent detection
> //        - ESP32 protect from race in RMT code
> // 4.2.62 - Update IO_RotaryEncoder.h to ignore sending current position
> //        - Update IO_EXTurntable.h to remove forced I2C clock speed
> //        - Show device offline if EX-Turntable not connected
> // 4.2.61 - MAX_CURRENT restriction (caps motor shield value)
> // 4.2.60 - Add mDNS capability to ESP32 for autodiscovery
> // 4.2.59 - Fix: AP SSID was DCC_ instead of DCCEX_
> // 4.2.58 - Start motordriver as soon as possible but without waveform
> // 4.2.57 - New overload handling (faster and handles commonFaultPin again)
> //        - Optimize analog read STM32
> // 4.2.56 - Update IO_RotaryEncoder.h:
> //        - Improved I2C communication, non-blocking reads
> //        - Enable sending positions to the encoder from EXRAIL via SERVO()
> // 4.2.55 - Optimize analog read for AVR
> // 4.2.54 - EX8874 shield in config.example.h
> //        - Fix: Better warnings for pin number errors
> //        - Fix: Default roster list possible in Withrottle and <jR>
> //        - Fix: Pin handling supports pins up to 254
